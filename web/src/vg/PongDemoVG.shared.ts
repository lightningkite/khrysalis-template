// Generated by Khrysalis TypeScript converter - this file will be overwritten.
// File: vg/PongDemoVG.shared.kt
// Package: com.lightningkite.khrysalistemplate.vg
import { Paint } from 'khrysalis/dist/views/draw/Paint.actual'
import { PongDemoXml } from '../layout/PongDemoXml'
import { getAnimationFrame } from 'khrysalis/dist/delay.actual'
import { SubscriptionLike } from 'rxjs'
import { xCanvasDrawTextCentered } from 'khrysalis/dist/views/draw/Canvas.actual'
import { ViewGenerator } from 'khrysalis/dist/views/ViewGenerator.shared'
import { DisplayMetrics } from 'khrysalis/dist/views/DisplayMetrics.actual'
import { Shader, newLinearGradient } from 'khrysalis/dist/views/draw/LinearGradient.actual'
import { pathFromLTRB, pathOvalFromLTRB } from 'khrysalis/dist/views/draw/Path.actual'
import { CustomViewDelegate } from 'khrysalis/dist/views/CustomViewDelegate.shared'
import { numberToColor } from 'khrysalis/dist/views/Colors.actual'
import { xDisposableUntil } from 'khrysalis/dist/rx/DisposeCondition.actual'

//! Declares com.lightningkite.khrysalistemplate.vg.PongDemoVG
export class PongDemoVG extends ViewGenerator {
    public constructor() {
        super();
    }
    
    
    //! Declares com.lightningkite.khrysalistemplate.vg.PongDemoVG.title
    public get title(): string { return "Pong Test"; }
    
    
    public generate(dependency: Window): HTMLElement {
        const xml = new PongDemoXml();
        
        const view = xml.setup(dependency);
        
        return view;
    }
}

//! Declares com.lightningkite.khrysalistemplate.vg.PongDelegate
export class PongDelegate extends CustomViewDelegate {
    public constructor() {
        super();
        this.ballX = 0;
        this.ballY = 0;
        this.ballRadius = 5;
        this.ballVX = 100;
        this.ballVY = 100;
        this.stageHalfLength = 100;
        this.stageHalfWidth = 50;
        this.paddleOffset = 20;
        this.paddleHalfThickness = 5;
        this.paddleHalfWidth = 10;
        this.paddleLeftY = 0;
        this.paddleRightY = 0;
        this.scoreLeft = 0;
        this.scoreRight = 0;
        this.paint = new Paint();
        this.paint.color = numberToColor(0xFFFFFFFF);
        this.paint.textSize = 12;
        xDisposableUntil<SubscriptionLike>(getAnimationFrame().subscribe((time: number): void => {
                    this.frame(time);
                    this.postInvalidate();
        }, undefined, undefined), this.removed);
        this.width = 1;
        this.height = 1;
    }
    
    public ballX: number;
    
    public ballY: number;
    
    public ballRadius: number;
    
    public ballVX: number;
    
    public ballVY: number;
    
    public stageHalfLength: number;
    
    public stageHalfWidth: number;
    
    public paddleOffset: number;
    
    public paddleHalfThickness: number;
    
    public paddleHalfWidth: number;
    
    public paddleLeftY: number;
    
    public paddleRightY: number;
    
    
    public scoreLeft: number;
    
    public scoreRight: number;
    
    
    public frame(time: number): void {
        this.ballX = this.ballX + this.ballVX * time;
        this.ballY = this.ballY + this.ballVY * time;
        if (this.ballY > this.stageHalfWidth - this.ballRadius) {
            this.ballVY = (-Math.abs(this.ballVY));
            this.ballY = this.stageHalfWidth - this.ballRadius;
        }
        if (this.ballY < (-this.stageHalfWidth) + this.ballRadius) {
            this.ballVY = Math.abs(this.ballVY);
            this.ballY = (-this.stageHalfWidth) + this.ballRadius;
        }
        if (Math.abs(this.ballX - (-(this.stageHalfLength - this.paddleOffset))) < this.paddleHalfThickness + this.ballRadius) {
            if (Math.abs(this.ballY - this.paddleLeftY) < this.paddleHalfWidth + this.ballRadius) {
                this.ballVX = Math.abs(this.ballVX);
            }
        }
        if (Math.abs(this.ballX - (this.stageHalfLength - this.paddleOffset)) < this.paddleHalfThickness + this.ballRadius) {
            if (Math.abs(this.ballY - this.paddleRightY) < this.paddleHalfWidth + this.ballRadius) {
                this.ballVX = (-Math.abs(this.ballVX));
            }
        }
        if (this.ballX < (-this.stageHalfLength)) {
            this.ballX = 0;
            this.ballY = 0;
            this.ballVX = (-this.ballVX);
            this.scoreRight = this.scoreRight + 1;
        } else { if (this.ballX > this.stageHalfLength) {
                this.ballX = 0;
                this.ballY = 0;
                this.ballVX = (-this.ballVX);
                this.scoreLeft = this.scoreLeft + 1;
        } }
    }
    
    public readonly paint: Paint;
    
    
    
    
    public draw(canvas: CanvasRenderingContext2D, width: number, height: number, displayMetrics: DisplayMetrics): void {
        this.width = width;
        this.height = height;
        if (this.paint.shader === null) {
            this.paint.shader = newLinearGradient(0, 0, width, height, [numberToColor(0xFFFF0000), numberToColor(0xFF0000FF)], [0, 1], Shader.TileMode.REPEAT);
        }
        this.paint.render(canvas, pathFromLTRB(this.transformX((-this.stageHalfLength) + this.paddleOffset - this.paddleHalfThickness), this.transformY(this.paddleLeftY - this.paddleHalfWidth), this.transformX((-this.stageHalfLength) + this.paddleOffset + this.paddleHalfThickness), this.transformY(this.paddleLeftY + this.paddleHalfWidth)));
        this.paint.render(canvas, pathFromLTRB(this.transformX(this.stageHalfLength - this.paddleOffset - this.paddleHalfThickness), this.transformY(this.paddleRightY - this.paddleHalfWidth), this.transformX(this.stageHalfLength - this.paddleOffset + this.paddleHalfThickness), this.transformY(this.paddleRightY + this.paddleHalfWidth)));
        this.paint.render(canvas, pathOvalFromLTRB(this.transformX(this.ballX - this.ballRadius), this.transformY(this.ballY - this.ballRadius), this.transformX(this.ballX + this.ballRadius), this.transformY(this.ballY + this.ballRadius)));
        this.paint.textSize = height / 6;
        xCanvasDrawTextCentered(canvas, `${this.scoreLeft} - ${this.scoreRight}`, this.transformX(0), this.transformY((-this.stageHalfWidth) / 2), this.paint);
    }
    
    public onTouchDown(id: number, x: number, y: number, width: number, height: number): boolean {
        return this.onTouchUp(id, x, y, width, height);
    }
    
    public onTouchMove(id: number, x: number, y: number, width: number, height: number): boolean {
        return this.onTouchUp(id, x, y, width, height);
    }
    
    public onTouchUp(id: number, x: number, y: number, width: number, height: number): boolean {
        if (this.reverseX(x) < 0) {
            this.paddleLeftY = this.reverseY(y);
        } else {
            this.paddleRightY = this.reverseY(y);
        }
        return true;
    }
    
    public width: number;
    
    public height: number;
    
    public transformX(x: number): number {
        return (x + this.stageHalfLength) / (this.stageHalfLength * 2) * this.width;
    }
    
    public transformY(y: number): number {
        return (y + this.stageHalfWidth) / (this.stageHalfWidth * 2) * this.height;
    }
    
    public reverseX(x: number): number {
        return (x - this.width / 2) / this.width * this.stageHalfLength * 2;
    }
    
    public reverseY(y: number): number {
        return (y - this.height / 2) / this.height * this.stageHalfWidth * 2;
    }
    
    public generateAccessibilityView(): (HTMLElement | null) { 
        return null; 
    }
    
    public sizeThatFitsWidth(width: number, height: number): number {
        const scale = Math.min((width) / (this.stageHalfLength), (height) / (this.stageHalfWidth));
        
        return this.stageHalfLength * scale;
    }
    
    public sizeThatFitsHeight(width: number, height: number): number {
        const scale = Math.min((width) / (this.stageHalfLength), (height) / (this.stageHalfWidth));
        
        return this.stageHalfWidth * scale;
    }
}

