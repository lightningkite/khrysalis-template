// Generated by Khrysalis Swift converter - this file will be overwritten.
// File: vg/MapDemoVG.kt
// Package: com.lightningkite.butterflytemplate.vg
import ButterflyMaps
import RxSwift
import UIKit
import Butterfly
import Foundation

public class MapDemoVG : ViewGenerator {
    override public init() {
        self.text = StandardObservableProperty(underlyingValue: "")
        self.position = StandardObservableProperty(underlyingValue: nil)
        self.options = StandardObservableProperty(underlyingValue: [])
        super.init()
        //Necessary properties should be initialized now
    }
    
    override public var title: String {
        get { return "Map Demo" }
    }
    
    public let text: StandardObservableProperty<String>
    public let position: StandardObservableProperty<GeoCoordinate?>
    public let options: StandardObservableProperty<Array<GeoAddress>>
    
    override public func generate(dependency: ViewControllerAccess) -> UIView {
        let xml = MapDemoXml()
        let view = xml.setup(dependency: dependency)
        
        xml.map.bindSelect(dependency: dependency, position: self.position)
        xml.select.bindString(observable: self.text)
        xml.options.bind(data: self.options, defaultValue: GeoAddress(), makeView: { (obs) -> UIView in 
                let xml = ComponentTextXml()
                let view = xml.setup(dependency: dependency)
                xml.label.bindString(observable: obs.map(read: { (it) -> String in it.oneLine() }))
                xml.xmlRoot.onClick(action: { () -> Void in self.position.value = obs.value.coordinate })
                return view
        })
        
        self.text.observableNN
            .debounce(.milliseconds(Int(1000)), scheduler: MainScheduler.instance)
            .distinctUntilChanged()
            .flatMap({ (it) -> Observable<Array<GeoAddress>> in dependency.geocode(address: it).observeOn(AndroidSchedulers.mainThread()).toObservable() })
            .subscribe(onNext: { (it) -> Void in self.options.value = it }, onError: nil, onCompleted: nil)
            .until(condition: view.removed)
        
        return view
    }
}


